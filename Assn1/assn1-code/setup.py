#! /usr/bin/python3

from Database import *
from mysql.connector import errorcode
from charm.toolbox.pairinggroup import PairingGroup,pc_element
from charm.schemes.pre_mg07 import *
from charm.core.engine.util import objectToBytes,bytesToObject
import pickle
from charm.core.math.integer import integer, serialize, deserialize

class Patient:
    def __init__(self, ID, proxy):
        self.ID = ID

        #public parameters of the proxy re-encrpytion
        self.pre = proxy.pre
        self.params = proxy.params

        # Three types of keys associated with General, Medical and Training type phr data
        # Each key is stored as a list in the structure [public ID, secret key]
        self.General = [ID + "General", proxy.keygen(ID + "General")]       # Age, blood type, birth date, weight
        self.Medical = [ID + "Medical", proxy.keygen(ID + "Medical")]       # medical service provider related
        self.Training = [ID + "Training", proxy.keygen(ID + "Training")]    # Training related


    # Proxy's re-encryption key should be generated by the Patient as it requires secret key input
    # Each re-encryption key is only for one type of health record
    def genRencryptionK(self, recordType, ID2, proxy):
        if recordType == "General":
            sk = self.General[1]
            ID = self.General[0]
        elif recordType == "Medical":
            sk = self.Medical[1]
            ID = self.Medical[0]
        elif recordType == "Training":
            sk = self.Training[1]
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return
        reEncryptionKey = self.pre.rkGen(self.params, sk, ID, ID2)
        proxy.addKey(ID, ID2, reEncryptionKey)  # store this key at the proxy
        #return reEncryptionKey


    # Remove the re-Encrpytion Key from the proxy for "recordType" and ID2 (entity ID)
    def removeRencryptionK(self, recordType, ID2, proxy):
        if recordType == "General":
            ID = self.General[0]
        elif recordType == "Medical":
            ID = self.Medical[0]
        elif recordType == "Training":
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return

        keystring = ID + ":" + ID2
        if keystring in proxy.reEncryptionKeys:
            del proxy.reEncryptionKeys[keystring]


    def dec(self, recordType, ciphertext):
        if recordType == "General":
            sk = self.General[1]
            ID = self.General[0]
        elif recordType == "Medical":
            sk = self.Medical[1]
            ID = self.Medical[0]
        elif recordType == "Training":
            sk = self.Training[1]
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return

        return self.pre.decryptFirstLevel(self.params, sk, ciphertext, ID)




# Class for entities such as Hospitals, Doctors, Insurance and Health Clubs
class Entity:
    def __init__(self, ID, proxy):
        self.ID =  ID
        self.sk = proxy.keygen(self.ID)         # private key

        # public parameters of the proxy re-encryption
        self.pre = proxy.pre
        self.params = proxy.params

    def dec(self, ciphertext):
        return self.pre.decryptSecondLevel(self.params, self.sk, ciphertext['IDsrc'], self.ID, ciphertext)
        # Regarding the 3rd input variable ciphertext['IDsrc'], we use this because ciphertext is a python dictionary.
        # The idsrc can be extracted directly from it and does not need to be explicity stated.


class Proxy:
    def __init__(self):
        self.setup()
        self.reEncryptionKeys = dict()  #A dictionary of Re Encryption Keys, stored at proxy

    def setup(self):
        self.group = PairingGroup('SS512', secparam=1024)
        self.pre = PreGA(self.group)
        (self.master_secret_key, self.params) = self.pre.setup()

    def keygen(self,ID):
        id_secret_key = self.pre.keyGen(self.master_secret_key, ID)
        return id_secret_key

    def enc(self, ID, msg):
        return self.pre.encrypt(self.params, ID, msg)

    def addKey(self, ID1, ID2, rk):
    # ID1 should be the full ID string e.g. AliceGeneral
        keystring = ID1 + ":" + ID2
        self.reEncryptionKeys[keystring] = rk


    def reEncrypt(self, ID1, ID2, ciphertext):
    # ID1 should be the full ID string e.g. AliceGeneral
    # ID2 always belongs to an entity
        keystring = ID1 + ":" + ID2
        if keystring in self.reEncryptionKeys:
            rk = self.reEncryptionKeys[keystring]
            return self.pre.reEncrypt(self.params, ID1, rk, ciphertext)
        else:
            print("No re-Encryption Key exists for this request")
            return



def main():
    proxy = Proxy()
    id1 = "Alice"
    id2 = "AIG Insurance"
    Alice = Patient(id1, proxy)
    AIGinsurance = Entity(id2, proxy)

    msg = "hello world!!!!!"
    ct = proxy.enc(Alice.General[0], msg)


    #db = Database()
    #db.insertRecord(Alice.General[0], ct)
    print(ct)
    ct_B_Serialise = objectToBytes(ct['C']['B'], proxy.group)
    ct_C_Serialise = serialize(ct['C']['C'])


    ct_B_Deserialise = bytesToObject(ct_B_Serialise, proxy.group)
    ct_C_Deserialise = deserialize(ct_C_Serialise)


    print("After Serialise: ", ct_B_Deserialise)
    print("After objectToBytes: ", ct_C_Deserialise)





    pt = Alice.dec("General",ct)
    #print (pt)

    reEncryptionKey = Alice.genRencryptionK("General", AIGinsurance.ID, proxy)
    ct2 = proxy.reEncrypt(Alice.General[0], AIGinsurance.ID, ct)
    #print(ct2)
    pt2 = AIGinsurance.dec(ct2)
    #print(pt2)

    #print (proxy.reEncryptionKeys)
    Alice.removeRencryptionK("General", AIGinsurance.ID, proxy)
    #print (proxy.reEncryptionKeys)


    return ct

if __name__ == "__main__": main()
