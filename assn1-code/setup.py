#! /usr/bin/python3

from Database import *
from mysql.connector import errorcode
from charm.toolbox.pairinggroup import PairingGroup,pc_element
from charm.schemes.pre_mg07 import *
from charm.core.engine.util import objectToBytes,bytesToObject
from charm.core.math.integer import integer, serialize, deserialize
import copy

class Patient:
    def __init__(self, ID, proxy):
        self.ID = ID

        #public parameters of the proxy re-encrpytion
        self.pre = proxy.pre
        self.params = proxy.params
        self.group = proxy.group

        # Three types of keys associated with General, Medical and Training type records
        # Each key is stored as a list in the structure [public ID, secret key]
        self.General = [ID + "General", proxy.keygen(ID + "General")]       # Age, blood type, birth date, weight
        self.Medical = [ID + "Medical", proxy.keygen(ID + "Medical")]       # medical service provider related
        self.Training = [ID + "Training", proxy.keygen(ID + "Training")]    # Training related


    # Encrypts the msg and stores it in Database
    def encStore(self, recordType, msg):
        if recordType == "General":
            ID = self.General[0]
        elif recordType == "Medical":
            ID = self.Medical[0]
        elif recordType == "Training":
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return
        ct = self.pre.encrypt(self.params, ID, msg)

        # Serialise the ct for storage in MySql using appropriate charm API for each element type
        # Differentiate between the Integer element and the PairingGroup elements (Otherwise cannot seialise)
        # After serialisation, type is byte
        db = Database()
        ctI = serialize(ct['C']['C'])               # type of ctI is Integer. Use serialise API
        del ct['C']['C']
        ctPg = objectToBytes(ct, self.group)       # type of ctPG is PairingGroup. Use objectToBytes API
        db.insertRecord(ID, ctI, ctPg)
        db.done()

    # Each re-encryption key is for only one type of health record (recordType). The delegatee is ID2.
    # Proxy's re-encryption key should be generated by the Delegator (Patient) as it requires secret key input
    # After the Patient generates the re-encryption key, it is stored at the Proxy by calling Proxy.addKey
    def genRencryptionK(self, recordType, ID2, proxy):
        if recordType == "General":
            sk = self.General[1]
            ID = self.General[0]
        elif recordType == "Medical":
            sk = self.Medical[1]
            ID = self.Medical[0]
        elif recordType == "Training":
            sk = self.Training[1]
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return
        reEncryptionKey = self.pre.rkGen(self.params, sk, ID, ID2)
        proxy.addKey(ID, ID2, reEncryptionKey)  # store this key at the proxy


    # Remove the re-Encrpytion Key from the proxy for "recordType" and delegatee (ID2)
    def removeRencryptionK(self, recordType, ID2, proxy):
        if recordType == "General":
            ID = self.General[0]
        elif recordType == "Medical":
            ID = self.Medical[0]
        elif recordType == "Training":
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return

        keystring = ID + ":" + ID2
        if keystring in proxy.reEncryptionKeys:
            del proxy.reEncryptionKeys[keystring]


    def dec(self, recordType, ciphertext):
        if recordType == "General":
            sk = self.General[1]
            ID = self.General[0]
        elif recordType == "Medical":
            sk = self.Medical[1]
            ID = self.Medical[0]
        elif recordType == "Training":
            sk = self.Training[1]
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return

        return self.pre.decryptFirstLevel(self.params, sk, ciphertext, ID)



# Class for entities such as Hospitals, Doctors, Insurance and Health Clubs
class Entity:
    def __init__(self, ID, proxy):
        self.ID =  ID
        self.sk = proxy.keygen(self.ID)         # private key

        # public parameters of the proxy re-encryption
        self.pre = proxy.pre
        self.params = proxy.params
        self.group = proxy.group

    # ciphertext here denotes to a '2nd-level' ciphertext which has been re-encrypted by the proxy.
    def dec(self, ciphertext):
        return self.pre.decryptSecondLevel(self.params, self.sk, ciphertext['IDsrc'], self.ID, ciphertext)
        # Regarding the 3rd input variable ciphertext['IDsrc'], we use this because ciphertext is a python dictionary.
        # The idsrc can be extracted directly from it and does not need to be explicity stated.


class Proxy:
    def __init__(self):
        self.setup()
        self.reEncryptionKeys = dict()  #A dictionary of Re-Encryption Keys, stored at proxy

    def setup(self):
        self.group = PairingGroup('SS512', secparam=1024)
        self.pre = PreGA(self.group)
        (self.master_secret_key, self.params) = self.pre.setup()

    def keygen(self,ID):
        id_secret_key = self.pre.keyGen(self.master_secret_key, ID)
        return id_secret_key

    # This function stores the re-encryption key (provided by the Delegator, ID1)
    # to a dictionary of re-encryption keys, for future look-up.
    # note: ID1 should be the full ID string e.g. AliceGeneral
    def addKey(self, ID1, ID2, rk):
        keystring = ID1 + ":" + ID2
        self.reEncryptionKeys[keystring] = rk


    # This function performs re-encryption of first level CT encrypted for ID1
    # to second level CT encrypted for ID2
    # note: ID1 should be the full ID string e.g. AliceGeneral
    def reEncrypt(self, ID1, ID2, ciphertext):
        keystring = ID1 + ":" + ID2
        if keystring in self.reEncryptionKeys:
            rk = self.reEncryptionKeys[keystring]
            return self.pre.reEncrypt(self.params, ID1, rk, ciphertext)
        else:
            print("No re-Encryption Key exists for this request")
            return



def main():
    # Setup keys and clean Database
    db1 = Database()
    db1.reset()
    proxy = Proxy()
    id1 = "Alice"
    id2 = "AIG Insurance"
    Alice = Patient(id1, proxy)
    AIGinsurance = Entity(id2, proxy)


    # Demonstrate Encryption, Storage and Retrieval
    msg = "Blood Type A+"
    Alice.encStore("General", msg)


    # Read MySql Database and re-construct Ciphertext
    # MySql returns a string. First convert it to a byte object
    # Then call the deSerialisation APIs from Charm
    # TODO: Move this from main to a function in Alice
    db = Database()
    rows = db.selectRecord(Alice.General[0])
    ctReconstructs = list()    # List of Ciphertexts
    for row in rows :
        ctI_bytes = bytes(row[0], 'utf-8')
        ctI_Reconstruct = deserialize(ctI_bytes)
        ctPg_bytes = bytes(row[1], 'utf-8')
        ctReconstruct = bytesToObject(ctPg_bytes, proxy.group)
        ctReconstruct['C']['C'] = ctI_Reconstruct
        pt = Alice.dec("General",ctReconstruct)
        print (pt)
        #ctReconstructs.append(ct_Reconstruct)
        # TODO: Might need to be careful that copy by value and not reference



    #reEncryptionKey = Alice.genRencryptionK("General", AIGinsurance.ID, proxy)
    #ct2 = proxy.reEncrypt(Alice.General[0], AIGinsurance.ID, ct)
    ##print(ct2)
    #pt2 = AIGinsurance.dec(ct2)
    ##print(pt2)

    ##print (proxy.reEncryptionKeys)
    #Alice.removeRencryptionK("General", AIGinsurance.ID, proxy)
    #print (proxy.reEncryptionKeys)


    return

if __name__ == "__main__": main()
