#! /usr/bin/python3

from Database import *
from mysql.connector import errorcode
from charm.toolbox.pairinggroup import PairingGroup,pc_element
from charm.schemes.pre_mg07 import *
from charm.core.engine.util import objectToBytes,bytesToObject
from charm.core.math.integer import integer, serialize, deserialize

class Patient:
    def __init__(self, ID, proxy):
        self.ID = ID

        #public parameters of the proxy re-encrpytion
        self.pre = proxy.pre
        self.params = proxy.params
        self.group = proxy.group

        # Three types of keys associated with General, Medical and Training type records
        # Each key is stored as a list in the structure [public ID, secret key]
        self.General = [ID + "General", proxy.keygen(ID + "General")]       # Age, blood type, birth date, weight
        self.Medical = [ID + "Medical", proxy.keygen(ID + "Medical")]       # medical service provider related
        self.Training = [ID + "Training", proxy.keygen(ID + "Training")]    # Training related


    # Encrypts the msg (of type recordType) and stores it in Database
    def store(self, recordType, msg):
        if recordType.lower() == "general":
            ID = self.General[0]
        elif recordType.lower() == "medical":
            ID = self.Medical[0]
        elif recordType.lower() == "training":
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return
        ct = self.pre.encrypt(self.params, ID, msg)

        # Serialise the ct for storage in MySql using appropriate charm API for each element type
        # Differentiate between the Integer element and the PairingGroup elements (Otherwise cannot seialise)
        # After serialisation, type is byte
        db = Database()
        ctI = serialize(ct['C']['C'])               # type of ctI is Integer. Use serialise API
        del ct['C']['C']
        ctPg = objectToBytes(ct, self.group)       # type of ctPG is PairingGroup. Use objectToBytes API
        db.insertRecord(ID, ctI, ctPg)
        db.done()


    # Decrypts Data from Database of type "recordType"
    def read(self, recordType):
        if recordType.lower() == "general":
            ID = self.General[0]
        elif recordType.lower() == "medical":
            ID = self.Medical[0]
        elif recordType.lower() == "training":
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return

        # 1. Read MySql Database to obtain string object
        # 2. Re-construct Ciphertext by converting it to a byte object, then call Charm's deSerialisation API
        # 3. Pass reconstructed ciphertext to dec() function to get plaintext
        db = Database()
        rows = db.selectRecord(ID)
        for row in rows :
            ctI_bytes = bytes(row[0], 'utf-8')              # Integer element of CT
            ctI_Reconstruct = deserialize(ctI_bytes)
            ctPg_bytes = bytes(row[1], 'utf-8')             # PairingGroup element of CT
            ctReconstruct = bytesToObject(ctPg_bytes, self.group)
            ctReconstruct['C']['C'] = ctI_Reconstruct       # Complete Ciphertext from Integer and Pairing Group element
            pt = self.dec(recordType, ctReconstruct)
            print (pt)
        db.done()

    # Each re-encryption key is for only one type of health record (recordType). The delegatee is ID2.
    # Proxy's re-encryption key should be generated by the Delegator (Patient) as it requires secret key input
    # After the Patient generates the re-encryption key, it is stored at the Proxy by calling Proxy.addKey
    def genRencryptionK(self, recordType, ID2, proxy):
        if recordType.lower() == "general":
            sk = self.General[1]
            ID = self.General[0]
        elif recordType.lower() == "medical":
            sk = self.Medical[1]
            ID = self.Medical[0]
        elif recordType.lower() == "training":
            sk = self.Training[1]
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return
        reEncryptionKey = self.pre.rkGen(self.params, sk, ID, ID2)
        proxy.addKey(ID, ID2, reEncryptionKey)  # store this key at the proxy


    # Remove the re-Encrpytion Key from the proxy for "recordType" and delegatee (ID2)
    def removeRencryptionK(self, recordType, ID2, proxy):
        if recordType.lower() == "general":
            ID = self.General[0]
        elif recordType.lower() == "medical":
            ID = self.Medical[0]
        elif recordType.lower() == "training":
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return

        keystring = ID + ":" + ID2
        if keystring in proxy.reEncryptionKeys:
            del proxy.reEncryptionKeys[keystring]
            print("Re-Encryption Key deleted")
        else:
            print("No such Re-Encryption Key exists")

    #called by read function
    def dec(self, recordType, ciphertext):
        if recordType.lower() == "general":
            sk = self.General[1]
            ID = self.General[0]
        elif recordType.lower() == "medical":
            sk = self.Medical[1]
            ID = self.Medical[0]
        elif recordType.lower() == "training":
            sk = self.Training[1]
            ID = self.Training[0]
        else:
            print("Please enter the correct record type")
            return

        return self.pre.decryptFirstLevel(self.params, sk, ciphertext, ID)

